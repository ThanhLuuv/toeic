<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOEIC Part 1 Question Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .loading {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-6">
    <div class="max-w-6xl mx-auto bg-white p-6 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold mb-6 text-center text-blue-800">TOEIC Part 1 Question Generator</h1>
        
                <!-- Configuration Panel -->
        

        <!-- Question Generation Panel -->
        <div class="bg-green-50 p-4 rounded-lg mb-6">
            <h2 class="text-xl font-semibold mb-4">Question Generation</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block font-semibold mb-2">Level:</label>
                    <select id="level" class="w-full p-2 border rounded-lg">
                        <option value="1">Level 1 - Basic</option>
                        <option value="2" selected>Level 2 - Intermediate</option>
                        <option value="3">Level 3 - Advanced</option>
                    </select>
                </div>
                <div>
                    <label class="block font-semibold mb-2">Topic:</label>
                    <select id="topic" class="w-full p-2 border rounded-lg">
                        <option value="people">People & Actions</option>
                        <option value="objects" selected>Objects & Spatial Relations</option>
                        <option value="landscape">Landscape/Environment</option>
                        <option value="mixed">Mixed</option>
                    </select>
                </div>
                <div>
                    <label class="block font-semibold mb-2">Number of Questions:</label>
                    <input type="number" id="questionCount" value="1" min="1" max="10" 
                           class="w-full p-2 border rounded-lg">
                </div>
            </div>

            <div class="mb-4">
                <label class="block font-semibold mb-2">Custom Description:</label>
                <textarea id="customDescription" rows="3" 
                          placeholder="Nh·∫≠p m√¥ t·∫£ t√πy ch·ªânh cho c√¢u h·ªèi (t√πy ch·ªçn)..."
                          class="w-full p-2 border rounded-lg resize-none"></textarea>
            </div>

            <button id="generateBtn" 
                    class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-semibold flex items-center gap-2">
                <span id="generateIcon">üöÄ</span>
                <span id="generateText">Generate Complete TOEIC Set (Questions + Images + Audio)</span>
            </button>
            

        </div>

        <!-- Progress -->
        <div class="mb-6" id="progressSection" style="display: none;">
            <div class="bg-gray-200 rounded-full h-2">
                <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p id="progressText" class="text-center mt-2 text-gray-600">Preparing...</p>
        </div>

        <!-- Results -->
        <div id="resultsSection" class="hidden">
            <h2 class="text-xl font-semibold mb-4">Generated Questions</h2>
            <div id="resultsContainer" class="space-y-4"></div>
            
            <div class="mt-6 flex gap-4">
                <button id="downloadJsonBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
                    üì• Download JSON
                </button>
                <button id="clearResultsBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg">
                    üóëÔ∏è Clear Results
                </button>
            </div>
        </div>

        <!-- Error Display -->
        <div id="errorSection" class="hidden bg-red-50 border border-red-200 rounded-lg p-4 mt-4">
            <h3 class="text-red-800 font-semibold mb-2">Error</h3>
            <p id="errorMessage" class="text-red-700"></p>
        </div>
    </div>

    <script>
        // Azure OpenAI Configuration Variables
        const AZURE_CONFIG = {
            endpoint: "https://toeic-sweden-data.openai.azure.com/",
            deployment: "gpt-4o-mini",
            subscription_key: "8HfQ8iX4oDhxqR8usQsws6oFX1pkGLlqYVQiBvtPgjM0cEN6LxPGJQQJ99BGACfhMk5XJ3w3AAABACOGbxjH",
            api_version: "2024-12-01-preview"
        };

        // API Keys for other services
        const GEMINI_API_KEY = 'AIzaSyBhEX-SGF9m-xfmjfwkaWCoysypwhnlsKE';
        const GOOGLE_TTS_KEY = 'AIzaSyAqO6_hgidkr_qandEMZUJlBcAhF3xOsUk';

        // Cloudinary config
        const CLOUDINARY_UPLOAD_URL = 'https://api.cloudinary.com/v1_1/deroljhou/image/upload';
        const CLOUDINARY_UPLOAD_URL_AUDIO = 'https://api.cloudinary.com/v1_1/deroljhou/video/upload';
        const CLOUDINARY_UPLOAD_PRESET = 'thue_re';

        let generatedQuestions = [];
        let generatedImages = [];
        let generatedAudio = [];

        // System prompt (same as provided)
        const TOEIC_SYSTEM_PROMPT = `B·∫°n l√† m·ªôt ng∆∞·ªùi t·∫°o ra d·ªØ li·ªáu c√¢u h·ªèi TOEIC Part 1. Tr·∫£ v·ªÅ JSON ch·ªâ ch·ª©a d·ªØ li·ªáu h·ª£p l·ªá, kh√¥ng gi·∫£i th√≠ch, kh√¥ng d√πng markdown.
    
        üßç Ng∆∞·ªùi & h√†nh ƒë·ªông      ‚âà 50%     (1‚Äì5 ng∆∞·ªùi, h√†nh ƒë·ªông r√µ r√†ng)  
        üì¶ ƒê·ªì v·∫≠t & v·ªã tr√≠        ‚âà 30%     (nh·∫•n m·∫°nh quan h·ªá kh√¥ng gian)  
        üåá C·∫£nh quan & m√¥i tr∆∞·ªùng ‚âà 20%     (ph√¥ng n·ªÅn, ki·∫øn tr√∫c, thi√™n nhi√™n)

        == DANH M·ª§C B·∫™Y ==
        trapId            | T√™n               | M√¥ t·∫£  
        ------------------|-------------------|--------------------------------------  
        singularPlural    | Singular ‚Üî Plural | Sai s·ªë √≠t / s·ªë nhi·ªÅu  
        keywordMisuse     | Keyword Misuse    | T·ª´ ƒë√∫ng nh∆∞ng sai h√†nh ƒë·ªông/v·ªã tr√≠  
        assumption        | Assumption        | M√¥ t·∫£ h√†nh ƒë·ªông kh√¥ng t·ªìn t·∫°i  
        similarSound      | Similar Sound     | Nh·∫ßm l·∫´n do √¢m gi·ªëng  
        homophone         | Homophone         | T·ª´ ƒë·ªìng √¢m kh√°c nghƒ©a  
        misfocus          | Misfocus          | T·∫≠p trung v√†o v·∫≠t ph·ª• kh√¥ng quan tr·ªçng  

        == ƒê·ªäNH NGHƒ®A LEVEL ==
        level         | M√¥ t·∫£ ·∫£nh + c√¢u h·ªèi                             | B·∫´y ƒë∆∞·ª£c ph√©p  
        --------------|--------------------------------------------------|--------------------------  
        1 Basic       | 1 ng∆∞·ªùi ho·∫∑c 1 v·∫≠t, n·ªÅn tr·ªëng, h√†nh ƒë·ªông r√µ      | Kh√¥ng d√πng b·∫´y  
        2 Intermediate| 2‚Äì4 ch·ªß th·ªÉ, b·ªëi c·∫£nh ƒë∆°n gi·∫£n                  | singularPlural, keywordMisuse, misfocus  
        3 Advanced    | Nhi·ªÅu ng∆∞·ªùi/v·∫≠t, ·∫£nh ph·ª©c t·∫°p, ho·∫°t ƒë·ªông song song | T·∫•t c·∫£ c√°c b·∫´y  

        == SCHEMA ==
        {
        "questionNumber": 1,
        "level": "Basic|Intermediate|Advanced",
        "imageDescription": "...",
        "subjectVocabulary": [{ "word": "...", "meaning": "...", "isCorrect": true }],
        "descriptiveVocabulary": [{ "word": "...", "meaning": "...", "isCorrect": false }],
        "choices": { "A": "...", "B": "...", "C": "..." },
        "choicesVi": { "A": "...", "B": "...", "C": "..." },
        "correctAnswer": "A",
        "explanation": "...",
        "traps": "..."
        }

        == KHI T·∫†O NHI·ªÄU C√ÇU H·ªéI ==
        ‚Üí Tr·∫£ v·ªÅ ARRAY JSON:
        [
        { ... },
        { ... },
        ...
        ]

        == EXAMPLE ==
        // CHO 1 C√ÇU:
        {
        "questionNumber": 1,
        "level": "Basic",
        "imageDescription": "A black-and-white photo shows a man holding a pen beside a closed laptop on a bare table.",
        "subjectVocabulary": [
            {"word": "man", "meaning": "ng∆∞·ªùi ƒë√†n √¥ng", "isCorrect": true},
            {"word": "pen", "meaning": "c√¢y b√∫t", "isCorrect": true},
            {"word": "laptop", "meaning": "m√°y t√≠nh x√°ch tay", "isCorrect": true},
            {"word": "book", "meaning": "quy·ªÉn s√°ch", "isCorrect": false}
        ],
        "descriptiveVocabulary": [
            {"word": "holding", "meaning": "ƒëang c·∫ßm", "isCorrect": true},
            {"word": "closed", "meaning": "ƒë√£ ƒë√≥ng", "isCorrect": true},
            {"word": "typing", "meaning": "ƒëang g√µ ph√≠m", "isCorrect": false},
            {"word": "beside", "meaning": "b√™n c·∫°nh", "isCorrect": true}
        ],
        "choices": {
            "A": "A man is holding a pen beside a closed laptop.",
            "B": "A man is typing on a laptop.",
            "C": "A book is on the table."
        },
        "choicesVi": {
            "A": "M·ªôt ng∆∞·ªùi ƒë√†n √¥ng ƒëang c·∫ßm c√¢y b√∫t b√™n c·∫°nh m√°y t√≠nh x√°ch tay ƒë√£ ƒë√≥ng.",
            "B": "M·ªôt ng∆∞·ªùi ƒë√†n √¥ng ƒëang g√µ ph√≠m tr√™n m√°y t√≠nh x√°ch tay.",
            "C": "M·ªôt quy·ªÉn s√°ch n·∫±m tr√™n b√†n."
        },
        "correctAnswer": "A",
        "explanation": "ƒê√°p √°n A ƒë√∫ng v√¨ m√¥ t·∫£ ch√≠nh x√°c h√†nh ƒë·ªông v√† v·ªã tr√≠ c√°c v·∫≠t. B sai v·ªÅ h√†nh ƒë·ªông (typing thay v√¨ holding), C sai v·ªÅ v·∫≠t th·ªÉ (book thay v√¨ pen).",
        "traps": "D√πng t·ª´ ƒë√∫ng (laptop) nh∆∞ng h√†nh ƒë·ªông sai (typing thay v√¨ holding pen), T·∫≠p trung sai v√†o v·∫≠t kh√¥ng c√≥ (book) thay v√¨ v·∫≠t ch√≠nh (pen)"
        }

        == QUY T·∫ÆC B·∫ÆT BU·ªòC ==
        - ƒê√°p √°n ƒë√∫ng l√† ƒë√°p √°n m√¥ t·∫£ ch√≠nh x√°c v·∫≠t th·ªÉ trong ·∫£nh kh√¥ng c·∫ßn ph·∫£i m√¥ t·∫£ ƒë·ªß, ch·ªâ c·∫ßn ƒë√∫ng v·ªÅ v·∫≠t th·ªÉ
        - ƒê√°p √°n sai l√† ƒë√°p √°n c√≥ c√°c l·ªói sai nh∆∞:
        + Sai v·ªÅ h√†nh ƒë·ªông
        + Sai v·ªÅ v·ªã tr√≠/ƒë·ªãa ƒëi·ªÉm
        + Sai v·ªÅ s·ªë l∆∞·ª£ng
        + Sai v·ªÅ th·ªùi gian
        - ƒê√°p √°n sai tr√°nh s·ª≠ d·ª•ng c√°c t·ª´ ƒë·ªìng nghƒ©a ho·∫∑c c√≥ nghƒ©a hao hao gi·ªëng m√¥ t·∫£ v√≠ d·ª• "Vi·∫øt tr√™n quy·ªÉn s·ªë" v√† "Vi·∫øt l√™n gi·∫•y"

        == QUY TR√åNH KI·ªÇM TRA NHANH ==
        - ƒê√°nh d·∫•u ch·ªß th·ªÉ ‚Äì h√†nh ƒë·ªông ‚Äì v·ªã tr√≠ ‚Äì s·ªë l∆∞·ª£ng trong imageDescription.
        - ƒê·ªëi chi·∫øu t·ª´ng l·ª±a ch·ªçn: C√¢u ƒë√∫ng kh·ªõp 100%; C√¢u sai l·ªách ‚â• 1 y·∫øu t·ªë.
        - Ki·ªÉm tra:
        + S·ªë t·ª´ (‚â§15)
        + Kh√¥ng m√†u s·∫Øc/√°nh s√°ng
        + D√πng ƒë√∫ng th√¨ hi·ªán t·∫°i ti·∫øp di·ªÖn
        + traps c√≥ ƒë·ªß
        - ƒê·∫£m b·∫£o output l√† array JSON n·∫øu nhi·ªÅu c√¢u.
        - üëâ CH·ªà TR·∫¢ V·ªÄ JSON, KH√îNG GI·∫¢I TH√çCH, KH√îNG MARKDOWN.
        `;

        // Upload image to Cloudinary
        async function uploadToCloudinary(base64Image) {
            const formData = new FormData();
            formData.append('file', base64Image);
            formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);

            const response = await fetch(CLOUDINARY_UPLOAD_URL, {
                method: 'POST',
                body: formData
            });
            const data = await response.json();
            return data.secure_url;
        }

        // Upload audio to Cloudinary
        async function uploadAudioToCloudinary(base64Audio) {
            function base64ToBlob(base64, mime = 'audio/mp3') {
                const byteString = atob(base64.split(',')[1] || base64);
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                return new Blob([ab], { type: mime });
            }
            const blob = base64ToBlob(base64Audio, 'audio/mp3');
            const formData = new FormData();
            formData.append('file', blob);
            formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
            const response = await fetch(CLOUDINARY_UPLOAD_URL_AUDIO, {
                method: 'POST',
                body: formData
            });
            const data = await response.json();
            return data.secure_url;
        }

        // Generate images using Gemini
        async function generateImages() {
            updateProgress(40, "Generating images with Gemini...");
            
            for (let i = 0; i < generatedQuestions.length; i++) {
                try {
                    updateProgress(40 + (i * 20 / generatedQuestions.length), `Generating image ${i + 1}/${generatedQuestions.length}...`);
                    const prompt = `${generatedQuestions[i].imageDescription}. IMPORTANT: Create a black and white photograph (monochrome, grayscale, no color), realistic and professional quality, suitable for TOEIC test, documentary style. The photo should always depict a Western setting, specifically in England or the USA. The image must look natural and unposed, similar to scenes used in standardized English exams. Do not include any color. The setting, people, and objects should clearly reflect either British or American environments.`;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            instances: { prompt },
                            parameters: { sampleCount: 1 }
                        })
                    });

                    const result = await response.json();

                    if (result.predictions?.[0]?.bytesBase64Encoded) {
                        const base64 = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        const url = await uploadToCloudinary(base64);
                        generatedImages[i] = url;
                        generatedQuestions[i].image = url;
                    } else {
                        throw new Error('Image generation failed');
                    }

                    await new Promise(resolve => setTimeout(resolve, 1000));
                } catch (error) {
                    console.error(`Error generating image ${i + 1}:`, error);
                    generatedImages[i] = null;
                    generatedQuestions[i].image = null;
                }
            }
        }

        // Generate audio using Google TTS
        async function generateAudio() {
            updateProgress(60, "Generating audio with Google TTS...");
            
            function fixPronunciation(text) {
                let fixedText = text;
                fixedText = fixedText.replace(/\ba man\b/gi, '<phoneme alphabet="ipa" ph="…ô m√¶n">a man</phoneme>');
                fixedText = fixedText.replace(/\ba woman\b/gi, '<phoneme alphabet="ipa" ph="…ô Ààw äm…ôn">a woman</phoneme>');
                fixedText = fixedText.replace(/\ba person\b/gi, '<phoneme alphabet="ipa" ph="…ô Ààp…úrs…ôn">a person</phoneme>');
                fixedText = fixedText.replace(/\ba boy\b/gi, '<phoneme alphabet="ipa" ph="…ô b…î…™">a boy</phoneme>');
                fixedText = fixedText.replace(/\ba girl\b/gi, '<phoneme alphabet="ipa" ph="…ô …°…úrl">a girl</phoneme>');
                fixedText = fixedText.replace(/\ba dog\b/gi, '<phoneme alphabet="ipa" ph="…ô d…î…°">a dog</phoneme>');
                fixedText = fixedText.replace(/\ba cat\b/gi, '<phoneme alphabet="ipa" ph="…ô k√¶t">a cat</phoneme>');
                fixedText = fixedText.replace(/\ba book\b/gi, '<phoneme alphabet="ipa" ph="…ô b äk">a book</phoneme>');
                fixedText = fixedText.replace(/\ba house\b/gi, '<phoneme alphabet="ipa" ph="…ô ha äs">a house</phoneme>');
                fixedText = fixedText.replace(/\ba car\b/gi, '<phoneme alphabet="ipa" ph="…ô k…ër">a car</phoneme>');
                return fixedText;
            }
            
            for (let i = 0; i < generatedQuestions.length; i++) {
                try {
                    updateProgress(60 + (i * 30 / generatedQuestions.length), `Generating audio ${i + 1}/${generatedQuestions.length}...`);
                    const q = generatedQuestions[i];
                    const maleVoice = 'en-US-Wavenet-D';
                    
                    const questionNumber = q.questionNumber || (i + 1);
                    const questionText = `Look at picture number ${questionNumber}.`;
                    
                    const answerA = q.choices.A || '';
                    const answerB = q.choices.B || '';
                    const answerC = q.choices.C || '';
                    
                    const ssmlContent = `
                        <speak>
                            <voice name="${maleVoice}">
                                <prosody rate="slow" pitch="medium">
                                    ${fixPronunciation(questionText)}
                                </prosody>
                                <break time="1.2s"/>
                               
                                <prosody rate="medium" pitch="medium">
                                    A. ${fixPronunciation(answerA)}
                                </prosody>
                                <break time="0.8s"/>
                               
                                <prosody rate="medium" pitch="medium">
                                    B. ${fixPronunciation(answerB)}
                                </prosody>
                                <break time="0.8s"/>
                               
                                <prosody rate="medium" pitch="medium">
                                    C. ${fixPronunciation(answerC)}
                                </prosody>
                            </voice>
                        </speak>
                    `;
                    
                    const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${GOOGLE_TTS_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            input: { ssml: ssmlContent },
                            voice: { languageCode: 'en-US', name: maleVoice },
                            audioConfig: {
                                audioEncoding: 'MP3',
                                speakingRate: 0.88,
                                pitch: 0.0
                            }
                        })
                    });
                    
                    const result = await response.json();
                    if (result.audioContent) {
                        const audioUrl = await uploadAudioToCloudinary(`data:audio/mp3;base64,${result.audioContent}`);
                        generatedAudio[i] = audioUrl;
                        generatedQuestions[i].audio = audioUrl;
                    } else {
                        throw new Error('Audio generation failed');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error(`Error generating audio ${i + 1}:`, error);
                    generatedAudio[i] = null;
                    generatedQuestions[i].audio = null;
                }
            }
        }

        // Call Azure OpenAI API
        async function callAzureOpenAI(messages, temperature = 1.0) {
            const url = `${AZURE_CONFIG.endpoint}openai/deployments/${AZURE_CONFIG.deployment}/chat/completions?api-version=${AZURE_CONFIG.api_version}`;
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'api-key': AZURE_CONFIG.subscription_key
                },
                body: JSON.stringify({
                    messages: messages,
                    max_tokens: 7000,
                    temperature: temperature,
                    top_p: 1.0
                })
            });
            
            if (!response.ok) {
                throw new Error(`Azure OpenAI API error: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }

        // Generate questions
        async function generateQuestions() {
            const level = document.getElementById('level').value;
            const topic = document.getElementById('topic').value;
            const questionCount = parseInt(document.getElementById('questionCount').value);
            const customDescription = document.getElementById('customDescription').value.trim();

            // Show progress
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('errorSection').classList.add('hidden');
            
            // Update button state
            const generateBtn = document.getElementById('generateBtn');
            const generateIcon = document.getElementById('generateIcon');
            const generateText = document.getElementById('generateText');
            
            generateBtn.disabled = true;
            generateIcon.textContent = '‚è≥';
            generateIcon.classList.add('loading');
            generateText.textContent = 'Generating...';

            try {
                updateProgress(10, 'Preparing request...');

                // Create user prompt
                let userPrompt = `T·∫°o ${questionCount} c√¢u toeic part 1 level ${level}`;
                
                if (topic !== 'mixed') {
                    userPrompt += ` ch·ªß ƒë·ªÅ ${topic}`;
                }
                
                if (customDescription) {
                    userPrompt += `, ${customDescription}`;
                }
                
                userPrompt += `.
                Ph·∫£i tu√¢n th·ªß ƒë·∫ßy ƒë·ªß c√°c nguy√™n t·∫Øc v√† y√™u c·∫ßu c·ªßa ƒë·ªÅ TOEIC Part 1, ƒë√∫ng level ${level}.
                QUAN TR·ªåNG: V√¨ t·∫°o ${questionCount} c√¢u h·ªèi, ph·∫£i tr·∫£ v·ªÅ ARRAY JSON ch·ª©a ${questionCount} object, kh√¥ng ph·∫£i object ƒë∆°n l·∫ª.
                Format: [{"questionNumber": 1, ...}, {"questionNumber": 2, ...}, {"questionNumber": 3, ...}].
                ƒê·∫∑c bi·ªát ph·∫£i tu√¢n th·ªß c√°c y√™u c·∫ßu sau:
                + C√°c t·ª´ ƒë√∫ng, sai c·ªßa subjectVocabulary v√† descriptiveVocabulary l√† 3/2
                + Kh√¥ng ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p ƒë·∫øn m√†u s·∫Øc, √°nh s√°ng, ch·∫•t li·ªáu
                + Kh√¥ng d√πng c√°c ƒë·ªông t·ª´, m√¥ t·∫£ c√≥ √Ω nghƒ©a t∆∞∆°ng t·ª± nhau nh∆∞ "placed" v√† "display"
                + imageDescription ph·∫£i m√¥ t·∫£ chi ti·∫øt, kh√¥ng g√¢y nh·∫ßm l·∫´n, n√≥i r√µ c√°c tr·∫°ng th√°i c·ªßa v·∫≠t th·ªÉ c√≥ trong ·∫£nh
                + c√°c choices sai tr√°nh tr∆∞·ªùng h·ª£p kh√¥ng ch·∫Øc ch·∫Øn v√≠ d·ª•: m√¥ t·∫£ ·∫£nh c√≥ "Con dao ƒë∆∞·ª£c ƒë·∫∑t tr√™n b√†n c√πng v·ªõi tr√°i c√¢y" ƒë√°p √°n sai l√† con dao ƒë∆∞·ª£c d√πng th√°i hoa qu·∫£`;

                updateProgress(30, 'Sending request to Azure OpenAI...');
                console.log(userPrompt);

                const messages = [
                    {
                        role: "system",
                        content: "You are a TOEIC Part 1 ‚Äì Photographs test data generator"
                    },
                    {
                        role: "user",
                        content: "D·ª±a v√†o n·ªôi dung sau " + TOEIC_SYSTEM_PROMPT+ userPrompt
                    }
                ];

                const response = await callAzureOpenAI(messages, 1.0);
                
                updateProgress(70, 'Processing response...');

                // Simple JSON parsing - clean response and parse directly
                let questions = [];
                
                // Clean the response - remove markdown and extra characters
                let cleanResponse = response.trim();
                cleanResponse = cleanResponse.replace(/```json\s*/g, '').replace(/```\s*/g, '');
                
                try {
                    // Try to parse as JSON directly
                    const parsed = JSON.parse(cleanResponse);
                    console.log('Direct JSON parsing successful');
                    
                    // Handle both single object and array
                    if (Array.isArray(parsed)) {
                        questions = parsed;
                    } else if (parsed && typeof parsed === 'object' && parsed.questionNumber) {
                        questions = [parsed];
                    } else {
                        throw new Error("Invalid JSON structure");
                    }
                    
                } catch (parseError) {
                    console.log('Direct parsing failed, trying to parse multiple objects...');
                    
                    // Try to find JSON array first
                    const arrayMatch = cleanResponse.match(/\[[\s\S]*\]/);
                    if (arrayMatch) {
                        try {
                            const parsed = JSON.parse(arrayMatch[0]);
                            console.log('Array JSON parsing successful');
                            questions = parsed;
                        } catch (arrayError) {
                            console.log('Array parsing failed, trying individual objects...');
                        }
                    }
                    
                    // If array parsing failed or no array found, try to parse individual JSON objects
                    if (questions.length === 0) {
                        console.log('Parsing individual JSON objects...');
                        
                        // Find all JSON objects in the response
                        let currentPos = 0;
                        while (currentPos < cleanResponse.length) {
                            // Find the start of a JSON object
                            const startPos = cleanResponse.indexOf('{', currentPos);
                            if (startPos === -1) break;
                            
                            // Find the matching closing brace
                            let braceCount = 0;
                            let endPos = startPos;
                            
                            for (let i = startPos; i < cleanResponse.length; i++) {
                                if (cleanResponse[i] === '{') {
                                    braceCount++;
                                } else if (cleanResponse[i] === '}') {
                                    braceCount--;
                                    if (braceCount === 0) {
                                        endPos = i + 1;
                                        break;
                                    }
                                }
                            }
                            
                            if (endPos > startPos) {
                                const jsonStr = cleanResponse.substring(startPos, endPos);
                                try {
                                    const parsed = JSON.parse(jsonStr);
                                    if (parsed && typeof parsed === 'object' && parsed.questionNumber) {
                                        // Check if we already have this question
                                        const exists = questions.some(q => q.questionNumber === parsed.questionNumber);
                                        if (!exists) {
                                            questions.push(parsed);
                                            console.log('Found question', parsed.questionNumber);
                                        }
                                    }
                                } catch (objectError) {
                                    console.log('Failed to parse object at position', startPos);
                                }
                            }
                            
                            currentPos = endPos;
                        }
                    }
                    
                    // If still no questions, try regex fallback
                    if (questions.length === 0) {
                        const objectMatch = cleanResponse.match(/\{[\s\S]*\}/);
                        if (objectMatch) {
                            try {
                                const parsed = JSON.parse(objectMatch[0]);
                                console.log('Single object fallback successful');
                                if (parsed && typeof parsed === 'object' && parsed.questionNumber) {
                                    questions = [parsed];
                                }
                            } catch (fallbackError) {
                                console.error('All parsing methods failed');
                                throw new Error("Kh√¥ng th·ªÉ ph√¢n t√≠ch JSON t·ª´ ph·∫£n h·ªìi");
                            }
                        } else {
                            throw new Error("Kh√¥ng t√¨m th·∫•y JSON h·ª£p l·ªá trong ph·∫£n h·ªìi");
                        }
                    }
                }

                console.log('Parsed questions count:', questions.length);
                console.log('Question numbers found:', questions.map(q => q.questionNumber));

                // Validate that we have at least one question
                if (questions.length === 0) {
                    throw new Error("Kh√¥ng th·ªÉ ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi n√†o t·ª´ ph·∫£n h·ªìi");
                }

                // Sort questions by questionNumber
                questions.sort((a, b) => (a.questionNumber || 0) - (b.questionNumber || 0));
                
                console.log('Final questions count:', questions.length);
                console.log('Expected count:', questionCount);

                updateProgress(90, 'Validating questions...');

                // Validate questions
                questions.forEach((q, index) => {
                    if (!q.imageDescription || !q.choices || !q.correctAnswer) {
                        throw new Error(`C√¢u h·ªèi ${index + 1} thi·∫øu th√¥ng tin b·∫Øt bu·ªôc`);
                    }
                });

                console.log('Successfully parsed questions:', questions);

                generatedQuestions = questions;
                
                // Randomize correct answer position before generating images/audio
                randomizeAnswer(generatedQuestions);
                
                updateProgress(35, 'Questions generated! Now generating images...');
                
                // Step 2: Generate images
                await generateImages();
                
                updateProgress(90, 'Images generated! Now generating audio...');
                
                // Step 3: Generate audio
                await generateAudio();
                
                updateProgress(100, 'Complete! All content generated successfully.');
                
                displayResults(generatedQuestions);
                
                // Auto-download the complete JSON with images and audio
                downloadJSON();
                
            } catch (error) {
                console.error('Generation error:', error);
                showError(error.message);
            } finally {
                // Reset button state
                generateBtn.disabled = false;
                generateIcon.textContent = 'üöÄ';
                generateIcon.classList.remove('loading');
                generateText.textContent = 'Generate Questions';
            }
        }

        // Th√™m h√†m randomizeAnswer ph√≠a ngo√†i generateQuestions
        function randomizeAnswer(questions) {
            questions.forEach(q => {
                // L·∫•y ƒë√°p √°n ƒë√∫ng ban ƒë·∫ßu (kh√¥ng m·∫∑c ƒë·ªãnh l√† A)
                const originalCorrect = q.correctAnswer;
                const originalChoices = { ...q.choices };
                const originalChoicesVi = q.choicesVi ? { ...q.choicesVi } : undefined;
                const allPositions = ['A', 'B', 'C'];
                // L·∫•y ƒë√°p √°n sai
                const originalWrongs = allPositions.filter(pos => pos !== originalCorrect);

                // Random v·ªã tr√≠ m·ªõi cho ƒë√°p √°n ƒë√∫ng
                const shuffled = allPositions.slice().sort(() => Math.random() - 0.5);
                const newCorrect = shuffled[0];
                const newWrongs = [shuffled[1], shuffled[2]];

                // T·∫°o choices m·ªõi
                const newChoices = {};
                const newChoicesVi = q.choicesVi ? {} : undefined;
                newChoices[newCorrect] = originalChoices[originalCorrect];
                if (newChoicesVi) newChoicesVi[newCorrect] = originalChoicesVi[originalCorrect];
                newChoices[newWrongs[0]] = originalChoices[originalWrongs[0]];
                if (newChoicesVi) newChoicesVi[newWrongs[0]] = originalChoicesVi[originalWrongs[0]];
                newChoices[newWrongs[1]] = originalChoices[originalWrongs[1]];
                if (newChoicesVi) newChoicesVi[newWrongs[1]] = originalChoicesVi[originalWrongs[1]];

                // C·∫≠p nh·∫≠t l·∫°i choices v√† correctAnswer
                q.choices = newChoices;
                if (newChoicesVi) q.choicesVi = newChoicesVi;
                q.correctAnswer = newCorrect;

                // C·∫≠p nh·∫≠t explanation v√† traps n·∫øu c√≥
                if (q.explanation) {
                    // Thay th·∫ø "ƒê√°p √°n X ƒë√∫ng" th√†nh v·ªã tr√≠ m·ªõi
                    q.explanation = q.explanation
                        .replace(new RegExp(`ƒê√°p √°n ${originalCorrect} ƒë√∫ng`, 'gi'), `ƒê√°p √°n ${newCorrect} ƒë√∫ng`)
                        .replace(new RegExp(`${originalWrongs[0]} sai`, 'gi'), `${newWrongs[0]} sai`)
                        .replace(new RegExp(`${originalWrongs[1]} sai`, 'gi'), `${newWrongs[1]} sai`);
                }
                if (q.traps) {
                    // N·∫øu traps c√≥ nh·∫Øc ƒë·∫øn v·ªã tr√≠ ƒë√°p √°n, c≈©ng thay th·∫ø t∆∞∆°ng t·ª±
                    let traps = q.traps;
                    // ƒê·ªïi t·ª´ng v·ªã tr√≠ c≈© sang v·ªã tr√≠ m·ªõi
                    allPositions.forEach((pos, idx) => {
                        const newPos = shuffled[idx];
                        // ƒê·ªïi A, B, C th√†nh v·ªã tr√≠ m·ªõi t∆∞∆°ng ·ª©ng
                        const regex = new RegExp(`\b${pos}\b`, 'g');
                        traps = traps.replace(regex, newPos);
                    });
                    q.traps = traps;
                }
            });
        }

        // Display results
        function displayResults(questions) {
            const container = document.getElementById('resultsContainer');
            container.innerHTML = '';

            questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'bg-white border rounded-lg p-4 shadow-sm';
                
                questionDiv.innerHTML = `
                    <h3 class="text-lg font-semibold mb-3 text-blue-800">Question ${question.questionNumber || index + 1}</h3>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                        <div>
                            <h4 class="font-semibold mb-2">Image Description:</h4>
                            <p class="text-gray-700 mb-4">${question.imageDescription}</p>
                            
                            ${question.image ? `
                                <h4 class="font-semibold mb-2">Generated Image:</h4>
                                <img src="${question.image}" alt="Generated image" class="w-full max-w-xs rounded-lg shadow-sm mb-4">
                            ` : ''}
                            
                            ${question.audio ? `
                                <h4 class="font-semibold mb-2">Generated Audio:</h4>
                                <audio controls class="w-full mb-4">
                                    <source src="${question.audio}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>
                            ` : ''}
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-2">Choices:</h4>
                            <div class="space-y-2 mb-4">
                                <div class="p-2 bg-gray-50 rounded">
                                    <strong>A:</strong> ${question.choices.A}
                                    ${question.choicesVi ? `<br><em class="text-gray-600">${question.choicesVi.A}</em>` : ''}
                                </div>
                                <div class="p-2 bg-gray-50 rounded">
                                    <strong>B:</strong> ${question.choices.B}
                                    ${question.choicesVi ? `<br><em class="text-gray-600">${question.choicesVi.B}</em>` : ''}
                                </div>
                                <div class="p-2 bg-gray-50 rounded">
                                    <strong>C:</strong> ${question.choices.C}
                                    ${question.choicesVi ? `<br><em class="text-gray-600">${question.choicesVi.C}</em>` : ''}
                                </div>
                            </div>
                            
                            <div class="mb-4">
                                <strong>Correct Answer:</strong> 
                                <span class="text-green-600 font-semibold">${question.correctAnswer}</span>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-2">Subject Vocabulary:</h4>
                            <div class="mb-4">
                                ${question.subjectVocabulary ? question.subjectVocabulary.map(v => 
                                    `<div class="flex items-center gap-2 mb-1">
                                        <span class="w-4 h-4 rounded ${v.isCorrect ? 'bg-green-500' : 'bg-red-500'}"></span>
                                        <span>${v.word}</span>
                                        <span class="text-gray-600">(${v.meaning})</span>
                                    </div>`
                                ).join('') : 'N/A'}
                            </div>
                            
                            <h4 class="font-semibold mb-2">Descriptive Vocabulary:</h4>
                            <div class="mb-4">
                                ${question.descriptiveVocabulary ? question.descriptiveVocabulary.map(v => 
                                    `<div class="flex items-center gap-2 mb-1">
                                        <span class="w-4 h-4 rounded ${v.isCorrect ? 'bg-green-500' : 'bg-red-500'}"></span>
                                        <span>${v.word}</span>
                                        <span class="text-gray-600">(${v.meaning})</span>
                                    </div>`
                                ).join('') : 'N/A'}
                            </div>
                            
                            <h4 class="font-semibold mb-2">Explanation:</h4>
                            <p class="text-gray-700 mb-2">${question.explanation || 'N/A'}</p>
                            
                            <h4 class="font-semibold mb-2">Trap Analysis:</h4>
                            <p class="text-gray-700">${question.traps || 'N/A'}</p>
                        </div>
                    </div>
                `;
                
                container.appendChild(questionDiv);
            });

            document.getElementById('resultsSection').classList.remove('hidden');
        }

        // Update progress
        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // Show error
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorSection').classList.remove('hidden');
        }

        // Download JSON
        function downloadJSON() {
            const dataStr = JSON.stringify(generatedQuestions, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `toeic_part1_questions_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Clear results
        function clearResults() {
            generatedQuestions = [];
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('errorSection').classList.add('hidden');
            document.getElementById('progressSection').style.display = 'none';
        }

        // Configuration toggle functions
        function showConfiguration() {
            // Set the input values from the configuration variables
            document.getElementById('endpoint').value = AZURE_CONFIG.endpoint;
            document.getElementById('deployment').value = AZURE_CONFIG.deployment;
            document.getElementById('subscriptionKey').value = AZURE_CONFIG.subscription_key;
            document.getElementById('apiVersion').value = AZURE_CONFIG.api_version;
            
            document.getElementById('configPanel').style.display = 'block';
            document.getElementById('showConfigBtn').style.display = 'none';
        }

        function hideConfiguration() {
            document.getElementById('configPanel').style.display = 'none';
            document.getElementById('showConfigBtn').style.display = 'block';
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', generateQuestions);
        document.getElementById('downloadJsonBtn').addEventListener('click', downloadJSON);
        document.getElementById('clearResultsBtn').addEventListener('click', clearResults);

    </script>
</body>
</html>
